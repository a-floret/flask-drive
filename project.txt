ğŸ”¹ Ã‰tape 1 : Application Flask

    CrÃ©er une API Flask qui expose :

        - Une route /upload (upload dâ€™un fichier).
        - Une route /files (liste les fichiers disponibles et permet de les tÃ©lÃ©charger).
        - Les fichiers doivent Ãªtre stockÃ©s dans un dossier persistant (volume).

ğŸ”¹ Ã‰tape 2 : Base de donnÃ©es

    Ajouter une petite base SQLite (ou PostgreSQL si tu veux aller plus loin).
    Ã€ chaque upload, tu enregistres dans la base :
    nom du fichier
    taille
    date dâ€™upload

    La route /files doit renvoyer ces infos.

ğŸ”¹ Ã‰tape 3 : Conteneurisation

    Construire une image avec Podman/Docker pour ton app Flask.
    Monter un volume pour stocker les fichiers (afin quâ€™ils persistent aprÃ¨s un redÃ©marrage).

ğŸ”¹ Ã‰tape 4 : Multi-conteneurs

    Ajouter un deuxiÃ¨me conteneur Nginx (ou Caddy) :
    il sert les fichiers statiques (les uploads).
    il reverse-proxy les routes API vers Flask.

ğŸ”¹ Ã‰tape 5 : RÃ©seau

    CrÃ©er un rÃ©seau custom oÃ¹ Flask et Nginx communiquent.
    Depuis ton navigateur, tu ne parles quâ€™Ã  Nginx.

ğŸ”¹ Ã‰tape 6 : Kubernetes

    Transformer tout Ã§a en manifests K8s :

    1 Deployment Flask
    1 Deployment Nginx
    1 Service par composant
    1 PersistentVolumeClaim pour stocker les fichiers

    VÃ©rifier que lâ€™app reste dispo mÃªme si un Pod Flask redÃ©marre.

ğŸ”¹ Ã‰tape 7 (bonus) : ObservabilitÃ©

    Ajouter un sidecar conteneur qui logge les uploads (ex : un conteneur BusyBox qui lit un volume partagÃ© et imprime dans stdout).
